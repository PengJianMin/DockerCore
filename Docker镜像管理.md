# Docker镜像管理
+ libcontainer可以快速构建起应用的运行环境。但是当需要进行**容器迁移**，对容器的运行环境进行**全盘打包**时，libcontainer就束手无策了。
+ “镜像”技术作为Docker管理**文件系统**以及**运行环境**的强有力补充
# 什么是Docker镜像
+ Docker镜像是一个**只读**的Docker**容器模板**，含有启动Docker容器所需的**文件系统结构及其内容**
+ Docker镜像是Docker容器的**静态视角**，Docker容器是Docker镜像的**运行状态**
+ Docker镜像的**文件内容**以及一些运行Docker**容器的配置文件**组成了Docker容器的**静态文件系统运行环境——rootfs**
+ rootfs：Docker容器的**根目录**
1. rootfs是Docker容器在启动时**内部进程可见**的文件系统
2. rootfs通常包含一个操作系统运行所需的文件系统，例如可能包含典型的**类Unix操作系统中的目录系统**，**如/dev、/proc、/bin、/etc、/lib、/usr、/tmp及运行Docker容器所需的配置文件、工具等**
3. 在**传统的Linux操作系统内核启动**时，首先挂载一个**只读（read-only）的**rootfs，当系统检测其完整性之后，再将其切换为**读写（read-write）模式**
4. 在Docker架构中，当Docker daemon为Docker容器挂载rootfs时，**沿用了**Linux内核启动时的方法，即将rootfs设为只读模式。在挂载完毕之后，利用**联合挂载（union mount）技术**在已有的只读rootfs上**再挂载一个读写层**。这样，可读写层处于Docker容器文件系统的最顶层，其下**可能联合挂载多个只读层**，只有在Docker容器运行过程中**文件系统发生变化**时，才会把变化的文件内容写到可读写层，并**隐藏只读层中的老版本文件**
+ Docker镜像的主要**结构特点**
1. **分层**（Docker镜像**如此轻量**的重要原因） **镜像层、只读层、读写层**
    + Docker镜像是采用**分层的方式构建**的，每个镜像都由**一系列的“镜像层”** 组成
    + 当需要**修改**容器镜像内的某个文件时，只对处于最上方的**读写层进行变动**，不覆写下层已有文件系统的内容，已有文件**在只读层中的原始版本**仍然存在，但会被读写层中的新版文件所**隐藏**
    + 当使用**docker commit提交**这个**修改过的容器文件系统**为一个**新的镜像**时，保存的内容**仅为最上层**读写文件系统中**被更新过的文件**。
    + 分层达到了在**不同镜像之间共享镜像层**的效果
2. **写时复制（copy-on-write）**  **镜像层、容器层**
    + 在**多个容器之间**共享镜像，每个容器在启动的时候并不需要单独复制一份镜像文件，而是将**所有镜像层**以**只读的方式**挂载到一个挂载点，再在上面**覆盖**一个可读写的**容器层**。
    + 在未更改文件内容时，所有容器**共享同一份数据**
    + 只有在Docker容器运行过程中文件系统**发生变化**时，才会把变化的文件内容写到可读写层，并**隐藏**只读层中的**老版本文件**。
    + 写时复制配合分层机制减少了镜像对**磁盘空间的占用**和**容器启动时间**
3. **内容寻址存储（content-addressable storage）**
    + 根据文件内容来**索引**镜像和镜像层
    + 之前版本对每一个**镜像层**随机生成一个UUID（**已淘汰**），**新模型**对镜像层的**内容**计算校验和，生成一个**内容哈希值**，并以此哈希值**代替之前的UUID**作为**镜像层的唯一标志**
    + 该机制主要提高了**镜像的安全性**，并在**pull、push、load和save操作**后检测数据的完整性
    + 另外，基于内容哈希来索引镜像层，在一定程度上**减少了ID的冲突**并且**增强了镜像层的共享**，对于来自**不同构建**的镜像层，只要**拥有相同的内容哈希**，也能**被不同的镜像共享**
4. **联合挂载、联合文件系统（union filesystem）** 
    + 联合挂载技术可以在**一个挂载点（目录）** 同时挂载 **多个文件系统（分层）**，将挂载点的原目录与被挂载内容进行整合，使得最终可见的文件系统将会包含**整合之后的各层**的文件和目录
    + 联合挂载是用于**将多个镜像层的文件系统**挂载到**一个挂载点来**实现一个**统一文件系统视图**的途径，是下层存储驱动（如aufs、overlay等）实现**分层合并**的方式
    + 所以严格来说，联合挂载并**不是Docker镜像的必需技术**，比如我们在使用Device Mapper存储驱动时，其实是使用了快照技术来达到分层的效果，没有联合挂载这一概念
    + Ubuntu:14.04镜像后容器中的**aufs文件**系统为例
      + 由于初始挂载时**读写层为空**，所以从**用户的角度**看，该**容器的文件系统**与**底层的rootfs**没有差别
      + 从**内核的角度**来看，则是**显式区分**开来的两个层次。当需要修改镜像内的某个文件时，只对处于**最上方的读写层**进行了变动，**不覆写下层**已有文件系统的内容，已有文件在只读层中的**原始版本仍然存在**，但会被读写层中的**新版文件所隐藏**
      + 当**docker commit**这个修改过的**容器文件系统**为一个新的镜像时，保存的内容**仅为最上层读写**文件系统中被**更新过的文件**
      + ![aufs挂载Ubuntu 14.04文件系统示意图](https://github.com/PengJianMin/DockerCore/blob/main/aufs%E6%8C%82%E8%BD%BDUbuntu%2014.04%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)
5. Docker镜像的**存储组织方式**
    + ![ Docker容器文件系统的全局视图](https://github.com/PengJianMin/DockerCore/blob/main/Docker%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%A8%E5%B1%80%E8%A7%86%E5%9B%BE.jpg)
    + 除了echo hello进程所在的cgroups和namespace环境之外，容器文件系统其实是一个**相对独立的组织**
    + **可读写部分（read-write layer以及volumes）、init-layer、只读层（read-only layer）** 这3部分结构共同组成了一个容器所需的下层文件系统，它们通过联合挂载的方式**巧妙地表现为一层**，使得**容器进程**对这些层的存在**一点都不知道**
# Docker镜像关键概念
+  **registry** 
1. registry用以**保存Docker镜像**，其中还包括**镜像层次结构**和关于**镜像的元数据**
2. 用户可以在自己的数据中心搭建**私有的registry**，也可以使用Docker官方的**公用registry服务**，即**Docker Hub**
    + Docker Hub中有两种类型的仓库，即**用户仓库（user repository）** 与**顶层仓库（top-level repository）**
        + 用户仓库由**普通的**Docker Hub用户创建
        + 顶层仓库则由**Docker公司**负责维护，提供官方版本镜像。理论上，顶层仓库中的镜像经过Docker公司验证，被认为是**架构良好且安全的**
+  **repository**
1. 
