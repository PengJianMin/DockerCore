# 容器化思维
+ **技术角度**理解容器化思维
1. 容器的**本质**是一个**进程**以及**运行该进程所需要的各种依赖**
    + 我们就**不需要**去备份一个容器了，而是应该把需要备份的数据放在**容器外挂的volume里**或者**数据库里**
# SSH服务器的替代方案
1. Docker提供了一个 **`docker exec`** 命令，可以在**已运行**的容器中执行想要的命令，并得到反馈的结果
2. 对于用户需要**进入容器修改配置文件**的需求
    + 如果需要**长期使用**这份配置文件，那么它应该被**集成到镜像中**
    + 如果需要**经常修改**这份配置文件，那么应该使用**Docker数据卷共享**这份配置
3. **特殊需求**需要**进入容器**：可以使用`docker exec`**直接在容器中**启动一个shell，然后再进行一系列操作
```
docker run -d --name myFirstContainer -p 80:80 -v ~/data:/data ubuntu 
docker exec -it myFirstContainer /bin/bash
```
# Docker内应用日志管理方案
1. Docker对运行在它内部应用的日志管理较**薄弱**
    + 每个运行在容器内应用的日志输出统一保存在宿主机的/var/log目录下，文件夹以容器ID命名
    + Docker仅将应用的stdout和stderr两个日志输出通过通道重定向到/var/log下
    + Docker以JSON消息记录每一行日志，这将导致文件增长过快，从而超过主机磁盘限额
    + 日志没有自动切分功能
    + docker logs命令返回的日志记录也过于冗长
2. 处理Docker日志的**主流**方案
    + 在**容器内**收集。 除了正在运行的应用程序外，每个容器设置一个日志**收集进程**。这种方案需要定制Docker镜像
    + 在**容器外**收集。在**宿主机**上运行一个单独收集日志的代理，收集所有容器的日志。
        + 容器有一个从该宿主机挂载的**volume卷**，它们把日志记录在挂载卷中，由代理进程接收
        + 也可以使用代理**直接处理**存储在**/var/log目录**下的容器日志,该方案的典型代表为**Fluentd项目**
    + 在**专用容器**中收集。这是直接在宿主机上运行代理收集日志的**变种方案**。该收集代理同样运行在一个容器中，并且该容器的卷使用docker run的volumes-from选项被**绑定给所有**应用程序容器
# 容器化思维及更多
1. 容器化思维所包含的概念和实践方法——**微服务**
2. 微服务模式有如下三大特性
    + 彼此独立：微服务模式下的每一个组成部分，都是一个独立的服务，有一整套完整的运行机制以及**标准化的对外接口**。不依赖于其他部分就能正常运转，同时可以探测其他组成部分的存在。
    + 原子化：微服务应该是不可再分的原子化服务。如果一个服务还能继续划分为几个更小的服务，那便不能称为微服务，而更像是由多个微服务组成的“微系统”
    + 组合和重构：微服务的最大特点就在于它能快速地组合和重构，彼此组合成一个系统。系统里所有的实体在逻辑上是等价的，因此它的结构相对简单和松散，具有极强的可扩展性和鲁棒性
3. 容器化思维内的理念还包括**DevOps、持续集成和持续交付（CICD）以及不可变基础设施（immutable infrastructure）**
4. 
